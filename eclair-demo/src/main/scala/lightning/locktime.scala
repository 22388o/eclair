// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!

package lightning


import com.trueaccord.scalapb.Descriptors

@SerialVersionUID(0L)
final case class locktime(
    locktime: lightning.locktime.Locktime = lightning.locktime.Locktime.Empty
    ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[locktime] with com.trueaccord.lenses.Updatable[locktime] {
    @transient
    lazy val serializedSize: Int = {
      var __size = 0
      if (locktime.seconds.isDefined) { __size += com.google.protobuf.CodedOutputStream.computeUInt32Size(1, locktime.seconds.get) }
      if (locktime.blocks.isDefined) { __size += com.google.protobuf.CodedOutputStream.computeUInt32Size(2, locktime.blocks.get) }
      __size
    }
    def writeTo(output: com.google.protobuf.CodedOutputStream): Unit = {
      locktime.seconds.foreach { v => 
        output.writeUInt32(1, v)
      }
      locktime.blocks.foreach { v => 
        output.writeUInt32(2, v)
      }
    }
    def mergeFrom(__input: com.google.protobuf.CodedInputStream): lightning.locktime = {
      var __locktime = this.locktime
      var _done__ = false
      while (!_done__) {
        val _tag__ = __input.readTag()
        _tag__ match {
          case 0 => _done__ = true
          case 8 =>
            __locktime = lightning.locktime.Locktime.Seconds(__input.readUInt32())
          case 16 =>
            __locktime = lightning.locktime.Locktime.Blocks(__input.readUInt32())
          case tag => __input.skipField(tag)
        }
      }
      lightning.locktime(
          locktime = __locktime
      )
    }
    def getSeconds: Int = locktime.seconds.getOrElse(0)
    def withSeconds(__v: Int): locktime = copy(locktime = lightning.locktime.Locktime.Seconds(__v))
    def getBlocks: Int = locktime.blocks.getOrElse(0)
    def withBlocks(__v: Int): locktime = copy(locktime = lightning.locktime.Locktime.Blocks(__v))
    def clearLocktime: locktime = copy(locktime = lightning.locktime.Locktime.Empty)
    def withLocktime(__v: lightning.locktime.Locktime): locktime = copy(locktime = __v)
    def getField(__field: Descriptors.FieldDescriptor): Any = {
      __field.number match {
        case 1 => locktime.seconds
        case 2 => locktime.blocks
      }
    }
    def companion = lightning.locktime
}

object locktime extends com.trueaccord.scalapb.GeneratedMessageCompanion[locktime]  {
  implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[locktime]  = this
  def fromFieldsMap(fieldsMap: Map[Int, Any]): lightning.locktime = lightning.locktime(
    locktime = fieldsMap.getOrElse(1, None).asInstanceOf[Option[Int]].map(value => lightning.locktime.Locktime.Seconds(value)) orElse
fieldsMap.getOrElse(2, None).asInstanceOf[Option[Int]].map(value => lightning.locktime.Locktime.Blocks(value)) getOrElse lightning.locktime.Locktime.Empty
  )
  lazy val descriptor = new Descriptors.MessageDescriptor("locktime", this,
    None, m = Seq(),
    e = Seq(),
    f = lightning.InternalFields_srcMainProtobufLightningProto.internalFieldsFor("lightning.locktime"))
  lazy val defaultInstance = lightning.locktime(
  )
  sealed trait Locktime extends com.trueaccord.scalapb.GeneratedOneof {
    def isEmpty: Boolean = false
    def isDefined: Boolean = true
    def number: Int
    def isSeconds: Boolean = false
    def isBlocks: Boolean = false
    def seconds: Option[Int] = None
    def blocks: Option[Int] = None
  }
  object Locktime extends {
    @SerialVersionUID(0L)
    case object Empty extends Locktime {
      override def isEmpty: Boolean = true
      override def isDefined: Boolean = false
      override def number: Int = 0
    }
  
    @SerialVersionUID(0L)
    case class Seconds(value: Int) extends Locktime {
      override def isSeconds: Boolean = true
      override def seconds: Option[Int] = Some(value)
      override def number: Int = 1
    }
    @SerialVersionUID(0L)
    case class Blocks(value: Int) extends Locktime {
      override def isBlocks: Boolean = true
      override def blocks: Option[Int] = Some(value)
      override def number: Int = 2
    }
  }
  implicit class locktimeLens[UpperPB](_l: com.trueaccord.lenses.Lens[UpperPB, locktime]) extends com.trueaccord.lenses.ObjectLens[UpperPB, locktime](_l) {
    def seconds: com.trueaccord.lenses.Lens[UpperPB, Int] = field(_.getSeconds)((c_, f_) => c_.copy(locktime = lightning.locktime.Locktime.Seconds(f_)))
    def blocks: com.trueaccord.lenses.Lens[UpperPB, Int] = field(_.getBlocks)((c_, f_) => c_.copy(locktime = lightning.locktime.Locktime.Blocks(f_)))
    def locktime: com.trueaccord.lenses.Lens[UpperPB, lightning.locktime.Locktime] = field(_.locktime)((c_, f_) => c_.copy(locktime = f_))
  }
  final val SECONDS_FIELD_NUMBER = 1
  final val BLOCKS_FIELD_NUMBER = 2
}
